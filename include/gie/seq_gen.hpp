//================================================================================================================================================
// FILE: seq_gen.h
// (c) GIE 2011-08-01  17:07
//
//================================================================================================================================================
#ifndef H_GUARD_SEQ_GEN_2011_08_01_17_07
#define H_GUARD_SEQ_GEN_2011_08_01_17_07
//================================================================================================================================================
#pragma once
//================================================================================================================================================
#include <boost/range/counting_range.hpp>
//================================================================================================================================================
namespace gie {


	namespace seq {

		template <class T>
		struct elem_type_for {
			typedef T type;
		};


		template <class T, template <class> class elem_resolver = elem_type_for>
		boost::iterator_range< boost::counting_iterator< typename elem_resolver< T >::type > >
		u_bound(T const end) {
			typedef typename elem_resolver< T >::type elem_type;

			return ::boost::make_iterator_range( ::boost::counting_iterator<elem_type>(0), boost::counting_iterator<elem_type>( end ) );
		}

	} //end ns seq


}
//================================================================================================================================================
#endif
//================================================================================================================================================
